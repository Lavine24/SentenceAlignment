#include "alignment_models/hmm_aligner.h"

#include <cassert>
#include <limits>

#include "util/math_util.h"

using std::numeric_limits;

void HMMAligner::InitDataStructures(const vector<const ParallelCorpus*>& pcs,
                                const Vocab& total_source_vocab,
                                const Vocab& total_target_vocab) {
  source_vocab_size_ = total_source_vocab.size();
  target_vocab_size_ = total_target_vocab.size();
  t_table_ = new PackedTrie();
  t_table_->InitializeFromCorpus(pcs, total_source_vocab, total_target_vocab);
  expected_counts_ = new PackedTrie(*t_table_);

  // The distortion parameters must store values for -window_size_ to
  // window_size.
  distortion_params_ = new double[(window_size_ * 2) + 1];
  /*
  double uniform_prob = log((1.0 - exp(null_word_prob_))
      / ((window_size_ * 2.0) + 1.0));
  for (int i = 0; i < (window_size_ * 2) + 1; ++i) {
    distortion_params_[i] = uniform_prob;
  }*/
  // TODO: Temporary initialization
  double sum = exp(null_word_prob_);
  for (int i = 0; i < (window_size_ * 2) + 1; ++i) {
    distortion_params_[i] = 1.0;
    if (i == window_size_ + 1) {
      distortion_params_[i] += window_size_;
    }
    sum += distortion_params_[i];
  }
  for (int i = 0; i < (window_size_ * 2) + 1; ++i) {
    distortion_params_[i] = log(distortion_params_[i] / sum);
  }
  distortion_counts_ = new double[(window_size_ * 2) + 1];

  ClearExpectedCounts();
}

double HMMAligner::ScorePair(const Sentence& source, const Sentence& target) const {
  TransProbs* trans_probs = new TransProbs(source.size(), *this);
  HMMLattice* lattice = new HMMLattice(source.size(), target.size());

  for (int t = 0; t < target.size(); ++t) {
    // Transitions into non-null states
    for (int s = 0; s < source.size(); ++s) {
      double t_prob = t_table_->Prob(source[s], target[t]);

      double total_inc_prob = -numeric_limits<double>::max();
      for (int prev_s = -1; prev_s < source.size(); ++prev_s) {
        // The previous source word at the beginning of the lattice is fixed
        // to be -1 with prob 1
        if (t == 0) {
          total_inc_prob = trans_probs->at(prev_s, s) + t_prob;
          break;
        }
        double inc_prob = trans_probs->at(prev_s, s) + t_prob
            + MathUtil::LogAdd(lattice->at(prev_s, t - 1, false),
                               lattice->at(prev_s, t - 1, true));
        MathUtil::LogPlusEQ(total_inc_prob, inc_prob);
      }
      lattice->at(s, t, false) = total_inc_prob;
    }
    // Transitions into null states.
    double null_prob = t_table_->Prob(0, target[t]) + null_word_prob_;
    if (t > 0) {
      for (int s = 0; s < source.size(); ++s) {
        lattice->at(s, t, true) = null_word_prob_ + MathUtil::LogAdd(
            lattice->at(s, t-1, true), lattice->at(s, t-1, false));
      }
    } else {
      lattice->at(-1, t, true) = null_word_prob_;
    }
  }
  // Find the total probability by summing the last row.
  double result = lattice->at(-1, target.size() - 1, true);
  for (int s = 0; s < source.size(); ++s) {
    MathUtil::LogPlusEQ(result, lattice->at(s, target.size() - 1, false));
    MathUtil::LogPlusEQ(result, lattice->at(s, target.size() - 1, true));
  }

  delete trans_probs, lattice;
  return result;
}

// TODO Unchanged from M1
double HMMAligner::ViterbiScorePair(const Sentence& source, const Sentence& target)
    const {
  double result = 0.0;
  // The uniform alignment probability.
  double alignment_prob = log(1.0 / target.size());
  for (int t = 0; t < target.size(); ++t) {
    // The probability of generating this target word, initialized with the
    // probability of it being generated by the null source word.
    double max_prob = t_table_->Prob(0, target[t]);
    for (int s = 0; s < source.size(); ++s) {
      double p = t_table_->Prob(source[s], target[t]);
      if (p > max_prob) {
        max_prob = p;
      }
    }
    // Add the probability of generating this word to the 
    // The alignment probability can be factored out.
    result += max_prob + alignment_prob;
  }
  return result;
}

void HMMAligner::ClearExpectedCounts() {
  expected_counts_->Clear();
  for (int i = -window_size_; i <= window_size_; ++i) {
    dist_counts(i) = -numeric_limits<double>::max();
  }
}

double HMMAligner::EStep(const Sentence& source, const Sentence& target) {
  TransProbs* trans_probs = new TransProbs(source.size(), *this);
  HMMLattice* alphas = new HMMLattice(source.size(), target.size());

  // Compute alphas
  for (int t = 0; t < target.size(); ++t) {
    // Transitions into non-null states
    for (int s = 0; s < source.size(); ++s) {
      double t_prob = t_table_->Prob(source[s], target[t]);

      double total_inc_prob = -numeric_limits<double>::max();
      if (t == 0) {
        // The previous source word at the beginning of the sentence is fixed
        // to be -1 with probability 1.
        total_inc_prob = trans_probs->at(-1, s) + t_prob;
      } else {
        total_inc_prob = trans_probs->at(-1, s) + alphas->at(-1, t - 1, true);
        for (int prev_s = 0; prev_s < source.size(); ++prev_s) {
          double inc_prob = trans_probs->at(prev_s, s)
              + MathUtil::LogAdd(alphas->at(prev_s, t - 1, false),
                                 alphas->at(prev_s, t - 1, true));
          MathUtil::LogPlusEQ(total_inc_prob, inc_prob);
        }
        total_inc_prob += t_prob;
      }
      alphas->at(s, t, false) = total_inc_prob;
    }
    // Transitions into null states.
    double null_prob = t_table_->Prob(0, target[t]) + null_word_prob_;
    if (t > 0) {
      alphas->at(-1, t, true) = null_prob + alphas->at(-1, t - 1, true);
      for (int s = 0; s < source.size(); ++s) {
        alphas->at(s, t, true) = null_prob + MathUtil::LogAdd(
            alphas->at(s, t - 1, true), alphas->at(s, t - 1, false));
      }
    } else {
      alphas->at(-1, t, true) = null_prob;
    }
  }
  // Find the total probability by summing the last row.
  double result = alphas->at(-1, target.size() - 1, true);
  for (int s = 0; s < source.size(); ++s) {
    MathUtil::LogPlusEQ(result, alphas->at(s, target.size() - 1, false));
    MathUtil::LogPlusEQ(result, alphas->at(s, target.size() - 1, true));
  }
  
  HMMLattice* betas = new HMMLattice(source.size(), target.size());
  // Initialize the last row of betas to 1 (in the log domain)
  betas->at(-1, target.size() - 1, true) = 0.0;
  for (int s = 0; s < source.size(); ++s) {
    betas->at(s, target.size() - 1, false) = 0.0;
    betas->at(s, target.size() - 1, true) = 0.0;
  }
  // Result from the reverse direction
  double beta_result = -numeric_limits<double>::max();
  for (int t = target.size() - 1; t >= 0; --t) {
    // Transitions into non-null states
    for (int s = 0; s < source.size(); ++s) {
      double t_prob = t_table_->Prob(source[s], target[t]);
      double beta = betas->at(s, t, false);

      if (t > 0) {
        MathUtil::LogPlusEQ(betas->at(-1, t - 1, true),
            trans_probs->at(-1, s) + t_prob + beta); 
        // Updates to expected transition counts
        MathUtil::LogPlusEQ(dist_counts(s - (-1)), trans_probs->at(-1, s)
            + t_prob + beta + alphas->at(-1, t - 1, true) - result);
        for (int prev_s = 0; prev_s < source.size(); ++prev_s) {
          double inc_prob = trans_probs->at(prev_s, s) + t_prob + beta;
          MathUtil::LogPlusEQ(betas->at(prev_s, t - 1, false), inc_prob); 
          MathUtil::LogPlusEQ(betas->at(prev_s, t - 1, true), inc_prob); 
          // Updates to expected transition counts
          MathUtil::LogPlusEQ(dist_counts(s - prev_s), inc_prob
              + MathUtil::LogAdd(alphas->at(prev_s, t - 1, false),
                                 alphas->at(prev_s, t - 1, true))
              - result);
        }
      } else {
        // Only one update needs to be made for the beginning of the sentence
        MathUtil::LogPlusEQ(dist_counts(s - (-1)), trans_probs->at(-1, s)
            + t_prob + beta - result);
      }
    }
    // Transitions into null states.
    if (t > 0) {
      double null_prob = t_table_->Prob(0, target[t]) + null_word_prob_;
      for (int s = -1; s < (int) source.size(); ++s) {
        double inc_prob = null_prob + betas->at(s, t, true);
        MathUtil::LogPlusEQ(betas->at(s, t - 1, true), inc_prob);
        if (s != -1) {
          MathUtil::LogPlusEQ(betas->at(s, t - 1, false), inc_prob);
        }
      }
    }
    // Updates to the emission counts
    double null_value = alphas->at(-1, t, true) + betas->at(-1, t, true);
    for (int s = 0; s < source.size(); ++s) {
      double value = alphas->at(s, t, false) + betas->at(s, t, false);
      MathUtil::LogPlusEQ(expected_counts_->Lookup(source[s], target[t]),
          value - result);
      MathUtil::LogPlusEQ(null_value,
          alphas->at(s, t, true) + betas->at(s, t, true));
    }
    MathUtil::LogPlusEQ(expected_counts_->Lookup(0, target[t]), null_value - result);
  }
  for (int s = -1; s < (int) source.size(); ++s) {
    MathUtil::LogPlusEQ(beta_result, betas->at(s, 0, true)
        + alphas->at(s, 0, true));
    if (s != -1) {
      MathUtil::LogPlusEQ(beta_result, betas->at(s, 0, false)
          + alphas->at(s, 0, false));
    }
  }
 // std::cout << result << " " << beta_result << std::endl;

  delete trans_probs, alphas, betas;
  return result;
}

void HMMAligner::MStep(bool variational) {
  if (!variational) {
    if (emission_smoothing_ < 1.0) {
      std::cerr << "Can't use a regular M-Step with an alpha less than 1"
          << std::endl;
      assert(0);
    }
    for (int s = 0; s < source_vocab_size_; ++s) {
      double sum = -numeric_limits<double>::max();
      int min = expected_counts_->Offset(s);
      int max = expected_counts_->Offset(s+1);
      for (int i = min; i < max; ++i) {
        MathUtil::LogPlusEQ(expected_counts_->Data(i),
                            log(emission_smoothing_ - 1.0));
        MathUtil::LogPlusEQ(sum, expected_counts_->Data(i));
      }
      if (sum > -numeric_limits<double>::max()) {
        for (int i = min; i < max; ++i) {
          t_table_->Data(i) = expected_counts_->Data(i) - sum;
        }
      }
    }
    // Update the distortion parameters
    double distortion_sum = -numeric_limits<double>::max();
    for (int i = -window_size_; i <= window_size_; ++i) {
      MathUtil::LogPlusEQ(dist_counts(i), log(transition_smoothing_ - 1.0));
      MathUtil::LogPlusEQ(distortion_sum, dist_counts(i));
    }
    for (int i = -window_size_; i <= window_size_; ++i) {
      dist_probs(i) = exp(dist_counts(i) - distortion_sum);
      dist_probs(i) = log((1.0 - exp(null_word_prob_)) * dist_probs(i));
    }
  } else {
    // Variational Update
    assert(0); // TODO: Redo
  }
}

void HMMAligner::PrintTTable(const Vocab& source_vocab,
                             const Vocab& target_vocab,
                             std::ostream& out) const {
  t_table_->Print(source_vocab, target_vocab, out);
}

void HMMAligner::PrintDistortionCosts(const Vocab& source_vocab,
                                      const Vocab& target_vocab,
                                      std::ostream& out) const {
  out << -window_size_ << " or lower: "
      << exp(dist_probs(-window_size_)) << std::endl;
  for (int i = -window_size_ + 1; i < window_size_; ++i) {
    out << i << ": " << exp(dist_probs(i)) << std::endl;
  }
  out << window_size_ << " or higher: "
      << exp(dist_probs(window_size_)) << std::endl;
}

void HMMAligner::PrintModel(const Vocab& source_vocab,
                            const Vocab& target_vocab,
                            std::ostream& out) const {
  PrintTTable(source_vocab, target_vocab, out);
  PrintDistortionCosts(source_vocab, target_vocab, out);
}

HMMLattice::HMMLattice(int source_length, int target_length)
  : source_length_(source_length), target_length_(target_length) {
  lattice_ = new double*[target_length_];
  for (int i = 0; i < target_length_; ++i) {
    lattice_[i] = new double[(source_length_ + 1) * 2];
    for (int j = 0; j < (source_length_ + 1) * 2; ++j) {
      lattice_[i][j] = -numeric_limits<double>::max();
    }
  }
}

HMMLattice::~HMMLattice() {
  for (int i = 0; i < target_length_; ++i) {
    delete[] lattice_[i];
  }
  delete[] lattice_;
}

TransProbs::TransProbs(int source_length, const HMMAligner& hmm)
      : source_length_(source_length) {
  trans_probs_ = new double*[source_length_ + 1];
  for (int i = 0; i < source_length_ + 1; ++i) {
    trans_probs_[i] = new double[source_length_];
  }
  int window_size = hmm.window_size();

  for (int prev = -1; prev < source_length_; ++prev) {
    double total_prob = exp(hmm.null_word_prob());
    for (int next = 0; next < source_length_; ++next) {
      double p = exp(hmm.dist_probs(next - prev));
      if ((next - prev) <= -window_size) {
        p /= prev - window_size + 1;
      } else if ((next - prev) >= window_size) {
        p /= source_length_ - (prev + window_size);
      }
      trans_probs_[prev+1][next] = p;
      total_prob += p;
    }
    for (int next = 0; next < source_length_; ++next) {
      trans_probs_[prev+1][next] = 
        log(trans_probs_[prev+1][next] / total_prob);
    }
  }
}

TransProbs::~TransProbs() {
  for (int i = 0; i < source_length_ + 1; ++i) {
    delete[] trans_probs_[i];
  }
  delete[] trans_probs_;
}

