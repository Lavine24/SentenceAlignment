#include "alignment_models/hmm_aligner.h"

#include <cassert>
#include <limits>

#include "util/math_util.h"

using std::numeric_limits;

void HMMAligner::InitDataStructures(const vector<const ParallelCorpus*>& pcs,
                                const Vocab& total_source_vocab,
                                const Vocab& total_target_vocab) {
  source_vocab_size_ = total_source_vocab.size();
  target_vocab_size_ = total_target_vocab.size();
  t_table_ = new PackedTrie();
  t_table_->InitializeFromCorpus(pcs, total_source_vocab, total_target_vocab);
  //expected_counts_ = new PackedTrie(*t_table_);
  expected_counts_ = new PackedTrie();
  expected_counts_->InitializeFromCorpus(pcs, total_source_vocab, total_target_vocab);

  // The distortion parameters must store values for -window_size_ to
  // window_size.
  distortion_params_ = new double[(window_size_ * 2) + 1];
  distortion_counts_ = new double[(window_size_ * 2) + 1];

  ClearExpectedCounts();
}

double HMMAligner::ScorePair(const Sentence& source, const Sentence& target) const {
  TransProbs* trans_probs = new TransProbs(source.size(), *this);
  HMMLattice* lattice = new HMMLattice(source.size(), target.size());

  for (int t = 0; t < target.size(); ++t) {
    // Transitions into non-null states
    for (int s = 0; s < source.size(); ++s) {
      double t_prob = t_table_->Prob(source[s], target[t]);

      double total_inc_prob = -numeric_limits<double>::max();
      for (int prev_s = -1; prev_s < source.size(); ++prev_s) {
        // The previous source word at the beginning of the lattice is fixed
        // to be -1 with prob 1
        if (t == 0) {
          total_inc_prob = trans_probs->at(prev_s, s) + t_prob;
          break;
        }
        double inc_prob = trans_probs->at(prev_s, s) + t_prob
            + MathUtil::LogAdd(lattice->at(prev_s, t - 1, false),
                               lattice->at(prev_s, t - 1, true));
        MathUtil::LogPlusEQ(total_inc_prob, inc_prob);
      }
      lattice->at(s, t, false) = total_inc_prob;
    }
    // Transitions into null states.
    double null_prob = t_table_->Prob(0, target[t]) + null_word_prob_;
    if (t > 0) {
      for (int s = 0; s < source.size(); ++s) {
        lattice->at(s, t, true) = null_word_prob_ + MathUtil::LogAdd(
            lattice->at(s, t-1, true), lattice->at(s, t-1, false));
      }
    } else {
      lattice->at(-1, t, true) = null_word_prob_;
    }
  }
  // Find the total probability by summing the last row.
  double result = lattice->at(-1, target.size() - 1, true);
  for (int s = 0; s < source.size(); ++s) {
    MathUtil::LogPlusEQ(result, lattice->at(s, target.size() - 1, false));
    MathUtil::LogPlusEQ(result, lattice->at(s, target.size() - 1, true));
  }

  delete trans_probs, lattice;
  return result;
}

// TODO
double HMMAligner::ViterbiScorePair(const Sentence& source, const Sentence& target)
    const {
  double result = 0.0;
  // The uniform alignment probability.
  double alignment_prob = log(1.0 / target.size());
  for (int t = 0; t < target.size(); ++t) {
    // The probability of generating this target word, initialized with the
    // probability of it being generated by the null source word.
    double max_prob = t_table_->Prob(0, target[t]);
    for (int s = 0; s < source.size(); ++s) {
      double p = t_table_->Prob(source[s], target[t]);
      if (p > max_prob) {
        max_prob = p;
      }
    }
    // Add the probability of generating this word to the 
    // The alignment probability can be factored out.
    result += max_prob + alignment_prob;
  }
  return result;
}

void HMMAligner::ClearExpectedCounts() {
  expected_counts_->Clear();
  for (int i = -window_size_; i <= window_size_; ++i) {
    dist_counts(i) = -numeric_limits<double>::max();
  }
}

double HMMAligner::EStep(const Sentence& source, const Sentence& target) {
  TransProbs* trans_probs = new TransProbs(source.size(), *this);
  HMMLattice* alphas = new HMMLattice(source.size(), target.size());

  // Compute alphas
  for (int t = 0; t < target.size(); ++t) {
    // Transitions into non-null states
    for (int s = 0; s < source.size(); ++s) {
      double t_prob = t_table_->Prob(source[s], target[t]);

      double total_inc_prob = -numeric_limits<double>::max();
      for (int prev_s = -1; prev_s < source.size(); ++prev_s) {
        // The previous source word at the beginning of the alphas is fixed
        // to be -1 with prob 1
        if (t == 0) {
          total_inc_prob = trans_probs->at(prev_s, s) + t_prob;
          break;
        }
        double inc_prob = trans_probs->at(prev_s, s) + t_prob
            + MathUtil::LogAdd(alphas->at(prev_s, t - 1, false),
                               alphas->at(prev_s, t - 1, true));
        MathUtil::LogPlusEQ(total_inc_prob, inc_prob);
      }
      alphas->at(s, t, false) = total_inc_prob;
    }
    // Transitions into null states.
    double null_prob = t_table_->Prob(0, target[t]) + null_word_prob_;
    if (t > 0) {
      for (int s = -1; s < source.size(); ++s) {
        alphas->at(s, t, true) = null_word_prob_ + MathUtil::LogAdd(
            alphas->at(s, t - 1, true), alphas->at(s, t - 1, false));
      }
    } else {
      alphas->at(-1, t, true) = null_word_prob_;
    }
  }
  // Find the total probability by summing the last row.
  double result = alphas->at(-1, target.size() - 1, true);
  for (int s = 0; s < source.size(); ++s) {
    MathUtil::LogPlusEQ(result, alphas->at(s, target.size() - 1, false));
    MathUtil::LogPlusEQ(result, alphas->at(s, target.size() - 1, true));
  }
  
  HMMLattice* betas = new HMMLattice(source.size(), target.size());
  // Initialize the last row of betas to 1 (in the log domain)
  betas->at(-1, target.size() - 1, true) = 0.0;
  for (int s = 0; s < source.size(); ++s) {
    betas->at(s, target.size() - 1, false) = 0.0;
    betas->at(s, target.size() - 1, true) = 0.0;
  }
  for (int t = target.size() - 1; t >= 1; --t) {
    // Transitions into non-null states
    for (int s = 0; s < source.size(); ++s) {
      double t_prob = t_table_->Prob(source[s], target[t]);
      double beta = betas->at(s, t, false);
      for (int prev_s = -1; prev_s < source.size(); ++prev_s) {
        double inc_prob = trans_probs->at(prev_s, s) + t_prob + beta;
        MathUtil::LogPlusEQ(betas->at(prev_s, t - 1, false), inc_prob); 
        MathUtil::LogPlusEQ(betas->at(prev_s, t - 1, true), inc_prob); 
        // Updates to expected transition counts
        MathUtil::LogPlusEQ(dist_counts(s - prev_s), inc_prob
            + MathUtil::LogAdd(alphas->at(prev_s, t - 1, false),
                               alphas->at(prev_s, t - 1, true))
            );
      }
    }
    // Transitions into null states.
    double null_prob = t_table_->Prob(0, target[t]) + null_word_prob_;
    for (int s = -1; s < source.size(); ++s) {
      double inc_prob = null_word_prob_ + betas->at(s, t, true);
      MathUtil::LogPlusEQ(betas->at(s, t - 1, true), inc_prob);
      MathUtil::LogPlusEQ(betas->at(s, t - 1, false), inc_prob);
    }
    // Updates to the emission counts
    for (int s = 0; s < source.size(); ++s) {
      double value = alphas->at(s, t, false); // TODO
    }
  }

  delete trans_probs, alphas, betas;
  return result;
}

void HMMAligner::MStep(bool variational) {
  if (!variational) {
    if (emission_smoothing_ < 1.0) {
      std::cerr << "Can't use a regular M-Step with an alpha less than 1"
          << std::endl;
      assert(0);
    }
    for (int s = 0; s < source_vocab_size_; ++s) {
      double sum = -numeric_limits<double>::max();
      int min = expected_counts_->Offset(s);
      int max = expected_counts_->Offset(s+1);
      for (int i = min; i < max; ++i) {
        MathUtil::LogPlusEQ(expected_counts_->Data(i),
                            log(emission_smoothing_ - 1.0));
        MathUtil::LogPlusEQ(sum, expected_counts_->Data(i));
      }
      if (sum > -numeric_limits<double>::max()) {
        for (int i = min; i < max; ++i) {
          t_table_->Data(i) = expected_counts_->Data(i) - sum;
        }
      }
    }
    // Update the distortion parameters
    double distortion_sum = -numeric_limits<double>::max();
    for (int i = -window_size_; i <= window_size_; ++i) {
      MathUtil::LogPlusEQ(dist_counts(i), log(transition_smoothing_ - 1.0));
      MathUtil::LogPlusEQ(distortion_sum, dist_counts(i));
    }
    for (int i = -window_size_; i <= window_size_; ++i) {
      dist_probs(i) = dist_counts(i) - distortion_sum;
    }
  } else {
    // Variational Update
    assert(0); // TODO: Redo
  }
}

void HMMAligner::PrintTTable(const Vocab& source_vocab,
                             const Vocab& target_vocab,
                             std::ostream& out) const {
  t_table_->Print(source_vocab, target_vocab, out);
}

HMMLattice::HMMLattice(int source_length, int target_length)
  : source_length_(source_length), target_length_(target_length) {
  lattice_ = new double*[target_length_];
  for (int i = 0; i < target_length_; ++i) {
    lattice_[i] = new double[(source_length_ + 1) * 2];
    for (int j = 0; j < (source_length_ + 1) * 2; ++j) {
      lattice_[i][j] = -numeric_limits<double>::max();
    }
  }
}

HMMLattice::~HMMLattice() {
  for (int i = 0; i < target_length_; ++i) {
    delete[] lattice_[i];
  }
  delete[] lattice_;
}

TransProbs::TransProbs(int source_length, const HMMAligner& hmm)
      : source_length_(source_length) {
  trans_probs_ = new double*[source_length_ + 1];
  for (int i = 0; i < source_length_ + 1; ++i) {
    trans_probs_[i] = new double[source_length_];
  }

  for (int prev = -1; prev < source_length_; ++prev) {
    double total_prob = hmm.null_word_prob();
    for (int next = 0; next < source_length_; ++next) {
      MathUtil::LogPlusEQ(total_prob, hmm.dist_probs(next - prev));
    }
    for (int next = 0; next < source_length_; ++next) {
      trans_probs_[prev+1][next] = hmm.dist_probs(next - prev) - total_prob;
    }
  }
}

TransProbs::~TransProbs() {
  for (int i = 0; i < source_length_ + 1; ++i) {
    delete[] trans_probs_[i];
  }
  delete[] trans_probs_;
}

